---
title: "有限状态机(finite-state machine)"
date: 2019-12-28
categories:
  - Post
tags:
  - 设计模式
  - 有限状态机(FSM)
---
有限状态机是我们游戏程序中非常常用的一种设计模式。不止游戏，在AI和编译器程序方面很出名。  

## [什么是有限状态机?](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)

有限状态机是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型[^1]。(数学计算模型这个词要是觉得难理解，在脑海中换成结构即可。)  

### 有限状态机的元素

a.状态（status）
b.进入动作（entry action）:在进入状态时进行
c.退出动作（exit action）：在退出状态时进行
d.转移动作（transition action）在进行特定转移时进行  

![我自己在ward里面做的丑图]({{ site.url }}{{ site.baseurl }}/assets/../../assets/images/2019-12-28-FSM-Picture01.png)

### 写一个简单版本的有限状态机的例子

``` cs
    public class FSMMachine
    {
        List<Status> statuses = new List<Status>();
        public Status DefaultStatus{get;private set;}
        public Status CurrentStatus{get;private set;}
        Dictionary<Status,List<Transition>> s2tDic = new Dictionary<Status,List<Transition>>();
        bool running = false;

        public FSMMachine(Status defaultStatus)
        {
          DefaultStatus = defaultStatus;
          AddStatus(defaultStatus)
        }

        public void AddStatus(Status status)
        {
          if(statuses.Contains(status))
            return;

          statuses.Add(status);
        }

        public void RemoveStatus(Status status)
        {
          if(!statuses.Contains(status))
            return;

          //删除与这个Status有关的所有transition
          if(s2tDic.ContainKey(status))
          {
            s2tDic.Remove(status);
          }
          foreach(var kvp in s2tDic)
          {
            for(int i = kvp.Value.Count-1;i>=0;i--)
            {
              if(kvp.Value[i].NextStatus == status)
                kvp.Value.RemoveAt(i);
            }
          }
        }

        public Transition CreateTransition<T>(Status lastStatus,Status nextStatus) where T:Transition,new()
        {
          if(!statuses.Contains(lastStatus)||!statuses.Contains(nextStatus))
            return null;
          T transition = new T();
          transition.LastStatus = lastStatus;
          transition.NextStatus = nextStatus;

          if(!s2tDic.ContainsKey(transition.LastStatus))
            s2tDic.Add(transition.LastStatus,new List<Transition>());

          s2tDic[transition.LastStatus].Add(transition);
        }

        public DestroyTransition(Transition transition)
        {
          if(!statuses.Contain(transition.LastStatus)||!statuses.Contain(transition.NextStatus))
            return;

          if(!s2tDic.ContainKey(transition.LastStatus)||!s2tDic[transition.LastStatus].Contain(transition))
            return;

          s2tDic[transition.LastStatus].Remove(transition);
        }

       List<Transition> GetTransition(Status lastStatus,Status nextStatus)
        {
          if(!s2tDic.ContainKey(transition.LastStatus))
            return null;

          List<Transition> result = new List<Transition>();
          foreach(var transition in s2tDic[transition.LastStatus])
          {
            if (transition.NextStatus==nextStatus)
              result.Add(transition);
          }

          if(result.Count == 0)
            return null;
          else
            return result;
        }

        public void Run()
        {
          running = true;
          CurrentStatus = DefaultStatus;
          CurrentStatus.OnEnter();
        }

        public void ChangeStatus(Status status)
        {
          if(!statuses.Contains(status)||!!running)
            return;
          if(CurrentStatus!=null)
            CurrentStatus.OnLeave();

          //若有transition,执行transition，这里写的过于简单了，如果在游戏引擎或者在
          //其他地方会使用异步或者协程
          List<Transition> transitions = GetTransition(CurrentStatus,status);
          if(transitions!=null && transitions.Count>0)
          {
            foreach(var tran in transitions)
              tran.OnTransitionStart();

            foreach(var tran in transitions)
              tran.OnTransitionEnd();
          }

          status.OnEnter();
          CurrentStatus = status;
        }


    }
    public class Status
    {
        public virtual void OnEnter()
        {
          ……
        }

        public virtual void OnLeave()
        {
          ……
        }
    }

    public class Transition
    {
      public Status LastStatus;
      public Status NextStatus;

      public Transition()
      {
      }

      public virtual void OnTransitionStart()
      {
        ……
      }

      public virtual void OnTransitionEnd()
      {
        ……
      }
    }
```

……感觉作为一个实例来说，写得过于多了。如果觉得看着烦，可以只看方法名的。
这个简单版本的有限状态机，已经基本完成了。但是，有很多地方可以优化和拓展的.(我到时候会创个库专门写个自己的FSM贴在这里) 。  

比如说，我是直接通过ChangeStatus这个方法去转换状态的，这样也就造成我这个FSM状态的另一特点，就是无论两个状态之间有没有transition都是可以转换过去的。如果有，就会执行transition仅此而已。

而另一种常见的FSM是有parameter(参数)和condition(条件)的概念的。（例如unity的animator）这种是通过控制parameter来改变状态的，每次改变parameter时，遍历一遍以当前状态LastStatus的transition的condition，如果condition返回true，则开始转换。  
例如：状态A和状态B和转换T，转换T的连接着A和B，T的condition(条件)是parameter1(参数)为true。所以我把是parameter1变为true时，T就会检测到自己的条件满足，开始转换。

状态机除了基础的有限状态机，还有层次状态机和下推状态机。（游戏编程模式这本书里有介绍，有作者自己维护的网页版和中国人翻译的网页版）

参考：
[有限状态机wiki百科](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)  
[游戏编程模式](https://gpp.tkchu.me/state.html)

[^1]: 数学计算模型:这个词听上去好像学术，会让人感觉很难其实并没有。  简单来讲，数学计算模型是一种用于描述某种结构的具体组织方式的东西。只要这种结构能根据一组输入值，得到输出值。所以，这个听上去很高大上很学术的词，本身就是一个抽象的词用于描述一类东西的，我们不用太在意的。

